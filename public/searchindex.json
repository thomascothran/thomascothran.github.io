{"categories":[{"title":"CS","uri":"https://thomascothran.tech/categories/cs/"}],"posts":[{"content":"The polymath Blaise Pascal envisaged a triangle built of numbers. Pascal’s triangle — as it is usually called, despite the fact that its discovery predated Pascal by centuries — has the interesting property that each number is the sum of the two numbers directly above it.\nIn this post we will use Pascal’s triangle to demonstrate how recursion (i.e., a procedure that invokes itself in its definition) can be used to make complex problems easily soluble, using examples written in both Haskell and JavaScript. Wikipedia\nPascal’s triangle is constructed such that the first row has one number: 1. Each additional row adds one additional number. The third row, therefore, has three numbers; the 1,542nd row has 1,542 numbers. Each number is the sum of the two numbers above it, except for the 1 at the pinnacle.\nIf we want to solve a problem recursively, we start with what is easy. What is obvious about Pascal’s triangle? Well, to begin with, we have simply posited that the number in row 1 is 1. (This is the only number in the triangle that is not the sum of the numbers above it.) We also see that first and last column on each row will be a 1. The reason for this is that each of these is the sum of 1 and nothing (i.e, 0).\nLet’s say we need a function — let’s call it pt — that takes two integers, one representing a row and one the column. pt should return the number at that position. For instance, pt 1 1 should return 1, and pt 3 2 should return 3. (Note that we are not using zero based numbering for our rows and columns).\nOur type signature will be pt :: (Integer a) =\u0026gt; a -\u0026gt; a -\u0026gt; a. That is, is pt a function that takes two integers and returns an integer. Start with the easy answers\nWhen coming up with a recursive solution, we start with the easy answers. What’s the easiest case here? Well, the number at row 1 column 1 is 1!\npt :: Integer -\u0026gt; Integer -\u0026gt; Integer pt 1 1 = 1// JavaScript function pt(row, col) { if (a === 1 || b === 1) { return 1; } }  That was easy. What else can we say for sure? For one thing, there is nothing at a column less than 1. Nothing = zero. So if we ask pt for a position where the column is less than 1, pt should return 0.\npt :: Integer -\u0026gt; Integer -\u0026gt; Integer pt row col | row == 1 \u0026amp;\u0026amp; col == 1 = 1 | col \u0026lt; 1 = 0// JavaScript function pt(row, col) { if (row === 1 \u0026amp;\u0026amp; col === 1) { return 1; } else if (col \u0026lt; 1) { return 0; }  Come to think of it, if the column position is less than 1, that is just a special case where the number is outside Pascal’s triangle (in this case, to the left). What if the column position is outside the triangle to the right side? It would also be zero. We know that the total number of columns in a row is equal to the row number. Thus:\npt :: Integer -\u0026gt; Integer -\u0026gt; Integer pt row col | row == 1 \u0026amp;\u0026amp; col == 1 = 1 | col \u0026lt; 1 || col \u0026gt; row = 0// JavaScript function pt(row, col) { if (row === 1 \u0026amp;\u0026amp; col === 1) { return 1; } else if (col \u0026lt; 1 || col \u0026gt; row) { return 0; } }  After the easy questions, then what?\nThe nice thing about recursion is that we can just state what we know, and the computer will just figure out what we don’t. We know that any column outside the triangle will equal zero, and we know the triangle’s pinnacle is one.\nWe don’t need to manually figure out the numbers for any other position; we can just ask the computer to figure it out for us. All we need to do is describe to the computer what we need it to find. We can treat the program as magic, or the computer as an oracle.\npt :: Integer -\u0026gt; Integer -\u0026gt; Integer pt row col | row == 1 \u0026amp;\u0026amp; col == 1 = 1 | col \u0026lt; 1 || col \u0026gt; row = 0 | otherwise = (pt (row - 1) (col - 1)) + (pt (row - 1) (col))// JavaScript function pt(row, col) { if (row === 1 \u0026amp;\u0026amp; col === 1) { return 1; } else if (col \u0026lt; 1 || col \u0026gt; row) { return 0; } else { return (pt (row - 1, col - 1)) + (pt (row - 1, col)); } }  Magic!\nAnd there we have it! pt 1 1 returns 1, pt 3 2 returns two, and pt 17 5 returns 1820.\nBut it’s not really magic. There are a few things to keep in mind when constructing recursive functions, most importantly the base case imperative. Our base cases return answers, rather than recursively invoking the function. If we don’t hit the base cases eventually, the program will never terminate. The fact that the recursive call here decrements row each time means that we will eventually hit the first row.\nThe other thing to keep in mind is that this sort of recursive call is a form of tree recursion. The larger the numbers, the more resources the procedure will demand. The rate of growth here is exponential. My computer quickly gave me the answer to pt 17 5; I’m still waiting on the answer to pt 71 5.\n","id":0,"section":"posts","summary":"The polymath Blaise Pascal envisaged a triangle built of numbers. Pascal’s triangle — as it is usually called, despite the fact that its discovery predated Pascal by centuries — has the interesting property that each number is the sum of the two numbers directly above it.\nIn this post we will use Pascal’s triangle to demonstrate how recursion (i.e., a procedure that invokes itself in its definition) can be used to make complex problems easily soluble, using examples written in both Haskell and JavaScript.","tags":["recursion","haskell"],"title":"Haskell's Triangle","uri":"https://thomascothran.tech/2017/07/haskells-triangle/","year":"2017"},{"content":"A procedure is recursive if it invokes itself. Thus:\nconst toInfinityAndBeyond = num =\u0026gt; toInfinityAndBeyond(num + 1);  Of course, toInfinityAndBeyond is only useful if, rather than seeking an answer, you want to blow your call stack. But you see the point: we find toInfinityAndBeyond in its own body. What possible use could this be?\nRecursion is often well suited to express the logic of a problem. Let’s take a simple problem: the conversion of Roman to Arabic numerals. One solution is this one:\nfunction deromanize (str) { var\tstr = str.toUpperCase(), validator = /^M*(?:D?C{0,3}|C[MD])(?:L?X{0,3}|X[CL])(?:V?I{0,3}|I[XV])$/, token = /[MDLV]|C[MD]?|X[CL]?|I[XV]?/g, key = {M:1000,CM:900,D:500,CD:400,C:100,XC:90,L:50,XL:40,X:10,IX:9,V:5,IV:4,I:1}, num = 0, m; if (!(str \u0026amp;\u0026amp; validator.test(str))) return false; while (m = token.exec(str)) num += key[m[0]]; return num; }  We might be interested in solving this problem differently for a number of reasons, perhaps to avoid the pitfalls that go along with complex regular expressions, or because we want to avoid mutating variables. Most relevant for our purposes is the key object. Note how it includes not only M:1000, but also entries like CM: 900 and IV: 4. This hard wires crucial logic rather than expressing it.\nA First Stab Recursion gives us a more expressive way to approach the problem, one that allows us to use a single pure function that does not mutate variables. Here is a first stab:\nconst nums = {I: 1, V: 5, X: 10, L: 50, C: 100, M: 1000}; const arabify = (romNum) =\u0026gt; { if (romNum.length === 0) { return 0; } else if (nums[romNum[0]] \u0026lt; nums[romNum[1]]) { return (nums[romNum[1]] - nums[romNum[0]] + arabify(romNum.slice(2))); } else { return (nums[romNum[0]] + arabify(romNum.slice(1))); } }  This has the benefit of expressing the logic of converting valid (or even some invalid!) Roman numerals to Arabic numerals, but it has some problems as well. Let’s consider the good before the bad. The Good\nIn the first place, we are not using variables or complex regular expressions. More to the point, in our nums object, we have no need of shortcuts like IX: 9 or CM: 900 — our program handles this for us. How?\nThe function arabify takes a string, which we are assuming to be valid Roman numerals. If that string is empty, it simply returns 0. An empty string is our base case, the point at which arabify stops calling itself. Without a base case, the arabify calls will just keep piling up on the stack until there is a stack overflow.\nIf the string passed to arabify is not empty, we must determine the relation of the first two characters. If the first character is less than the second character — nums[romNum[0]] \u0026lt; nums[romNum[1] — we know that the former should be subtracted from the latter. That is, if X represents 10 and C a 100, then XC is 90.\nWhy in the case where the first two characters require the first be subtracted from the second do we need the call again to arabify? Because we could have a case like XCII, where we not only need to subtract the first item from the second, but the result must be added to the remaining numerals.\nIf the first numeral is not less than the second numeral, the solution is straightforward: add the first numeral to the value of the rest. We can simply call arabify on the remainder of the string from Roman numerals to find that value.\nThe Bad One downside to arabify is that it’s not the most readable. Wouldn’t it be nice if instead of having to parse things like nums[romNum[0]] \u0026lt; nums[romNum[1], we could have nums[fst] \u0026lt; nums[snd] instead?\nThe second problem is unlikely to arise in this particular context, but pointing it out is useful. The calls to arabify are going to keep piling on the call stack until the base case is reached — an empty string, then each call can be evaluated and the final answer returned. This means that arabify will consume memory roughly proportionally with the size of the string passed in as an argument.\nFortunately, the ES6 spec now includes tail call optimization. For recursive calls in the tail position, the function calls need no longer pile up on the stack. Let’s take a second stab at arabify that makes this clearer.\nTail Call Optimization arabify2 uses tail calls and is a bit easier to read.\nconst nums = {I: 1, V: 5, X: 10, L: 50, C: 100, M: 1000}; const arabify2 = (romNum, sum=0) =\u0026gt; { const [fst, snd, rest] = [romNum[0], romNum[1], romNum.slice(2)]; if (!snd) {return nums[fst] ? nums[fst] + sum : sum;} else if (nums[snd] \u0026gt; nums[fst]) { return arabify2(rest, nums[snd] - nums[fst] + sum); } else {return arabify2(snd + rest, nums[fst] + sum);} }  On line four, we use ES6 destructuring to so that we can say fst rather than romNum[0], snd rather than romNum[0], and rest rather than romNum.slice(2) or romNum.slice(1).\nNote the difference between the recursive calls to arabify2 in comparison to arabify: we don’t make a call to aribify2and then do something else with it. aribify2 uses the parameter sum to keep track of all the information it needs. There is no reason to ‘remember’ the previous aribify2 calls: the last call returns the result we are looking for.\n","id":1,"section":"posts","summary":"A procedure is recursive if it invokes itself. Thus:\nconst toInfinityAndBeyond = num =\u0026gt; toInfinityAndBeyond(num + 1);  Of course, toInfinityAndBeyond is only useful if, rather than seeking an answer, you want to blow your call stack. But you see the point: we find toInfinityAndBeyond in its own body. What possible use could this be?\nRecursion is often well suited to express the logic of a problem. Let’s take a simple problem: the conversion of Roman to Arabic numerals.","tags":["recursion","javascript"],"title":"Recursion Made Simple with Roman Numerals","uri":"https://thomascothran.tech/2017/07/recursion-with-roman-numerals/","year":"2017"}],"tags":[{"title":"haskell","uri":"https://thomascothran.tech/tags/haskell/"},{"title":"javascript","uri":"https://thomascothran.tech/tags/javascript/"},{"title":"recursion","uri":"https://thomascothran.tech/tags/recursion/"}]}